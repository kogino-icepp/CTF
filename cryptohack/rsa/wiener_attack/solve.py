import math
from fractions import Fraction
from Crypto.Util.number import *
class ContinuedFraction:
    def __init__(self, q: list):
        # m >= 1において、q_m >= 2を満たすため。
        if len(q) != 1 and q[-1] == 1:
            q = q[:-1]
            q[-1] += 1
            
        self._q = q
        self._nest = len(q) - 1
    
    @property
    def q(self):
        return self._q
    
    @property
    def nest(self):
        return self._nest
    
    def __str__(self):
        output_list = ["<"]
        for q_i in self.q:
            output_list.append(str(q_i))
            output_list.append(",")
        output_list[-1] = ">"
        return "".join(output_list)


def inv(f: Fraction):
    return Fraction(f.denominator, f.numerator)


def fraction_to_continued(f: Fraction):
    q_0 = math.floor(f)
    q = [q_0]
    previous_r_i = f - q_0
    
    while previous_r_i != 0:
        inv_previous_r_i = inv(previous_r_i)
        q_i = math.floor(inv_previous_r_i)
        previous_r_i = inv_previous_r_i - q_i
        
        q.append(q_i)
    
    return ContinuedFraction(q)

def continued_to_fraction(f: ContinuedFraction):
    q = f.q
    nest = f.nest
    
    n_0 = q[0]
    d_0 = 1
    if nest == 0:
        return Fraction(n_0, d_0)
    
    n_1 = q[0] * q[1] + 1
    d_1 = q[1]
    if nest == 1:
        return Fraction(n_1, d_1)
    
    n_i_minus_2 = n_0
    n_i_minus_1 = n_1
    d_i_minus_2 = d_0
    d_i_minus_1 = d_1
    
    n_i = None
    d_i = None
    
    # nest=len(q) - 1であるため
    for i in range(2, nest+1):
        n_i = q[i]*n_i_minus_1 + n_i_minus_2
        d_i = q[i]*d_i_minus_1 + d_i_minus_2
        
        n_i_minus_2, n_i_minus_1 = n_i_minus_1, n_i
        d_i_minus_2, d_i_minus_1 = d_i_minus_1, d_i
    
    return Fraction(n_i, d_i)


def calc_p_q_orelse(k, dg, e, n):
    if (e*dg) % k == 0:
        return -1, -1
    
    phi = e*dg // k
    
    if (n - phi + 1) % 2 != 0:
        return -1, -1
    
    X = (n - phi + 1) // 2
    Y2 = X*X - n
    
    if Y2 < 0:
        return -1, -1
    
    Y = math.isqrt(Y2)
    
    if Y*Y != Y2:
        return -1, -1
    
    return X+Y, X-Y



def wieners_attack(e, n):
    f_prime = Fraction(e, n)
    f_prime_continued = fraction_to_continued(f_prime)
    
    for i in range(f_prime_continued.nest+1):
        new_q = f_prime_continued.q[:i+1]
        if i % 2 == 0:
            new_q[-1] += 1
        new_continued_fraction = ContinuedFraction(new_q)
        new_fraction = continued_to_fraction(new_continued_fraction)
        k = new_fraction.numerator
        dg = new_fraction.denominator
        
        p, q = calc_p_q_orelse(k, dg, e, n)
        if p != -1 and q != -1:
            return p, q
    
    return -1, -1



n = 0xb8af3d3afb893a602de4afe2a29d7615075d1e570f8bad8ebbe9b5b9076594cf06b6e7b30905b6420e950043380ea746f0a14dae34469aa723e946e484a58bcd92d1039105871ffd63ffe64534b7d7f8d84b4a569723f7a833e6daf5e182d658655f739a4e37bd9f4a44aff6ca0255cda5313c3048f56eed5b21dc8d88bf5a8f8379eac83d8523e484fa6ae8dbcb239e65d3777829a6903d779cd2498b255fcf275e5f49471f35992435ee7cade98c8e82a8beb5ce1749349caa16759afc4e799edb12d299374d748a9e3c82e1cc983cdf9daec0a2739dadcc0982c1e7e492139cbff18c5d44529407edfd8e75743d2f51ce2b58573fea6fbd4fe25154b9964d
e = 0x9ab58dbc8049b574c361573955f08ea69f97ecf37400f9626d8f5ac55ca087165ce5e1f459ef6fa5f158cc8e75cb400a7473e89dd38922ead221b33bc33d6d716fb0e4e127b0fc18a197daf856a7062b49fba7a86e3a138956af04f481b7a7d481994aeebc2672e500f3f6d8c581268c2cfad4845158f79c2ef28f242f4fa8f6e573b8723a752d96169c9d885ada59cdeb6dbe932de86a019a7e8fc8aeb07748cfb272bd36d94fe83351252187c2e0bc58bb7a0a0af154b63397e6c68af4314601e29b07caed301b6831cf34caa579eb42a8c8bf69898d04b495174b5d7de0f20cf2b8fc55ed35c6ad157d3e7009f16d6b61786ee40583850e67af13e9d25be3
c = 0x3f984ff5244f1836ed69361f29905ca1ae6b3dcf249133c398d7762f5e277919174694293989144c9d25e940d2f66058b2289c75d1b8d0729f9a7c4564404a5fd4313675f85f31b47156068878e236c5635156b0fa21e24346c2041ae42423078577a1413f41375a4d49296ab17910ae214b45155c4570f95ca874ccae9fa80433a1ab453cbb28d780c2f1f4dc7071c93aff3924d76c5b4068a0371dff82531313f281a8acadaa2bd5078d3ddcefcb981f37ff9b8b14c7d9bf1accffe7857160982a2c7d9ee01d3e82265eec9c7401ecc7f02581fd0d912684f42d1b71df87a1ca51515aab4e58fab4da96e154ea6cdfb573a71d81b2ea4a080a1066e1bc3474
n = 383347712330877040452238619329524841763392526146840572232926924642094891453979246383798913394114305368360426867021623649667024217266529000859703542590316063318592391925062014229671423777796679798747131250552455356061834719512365575593221216339005132464338847195248627639623487124025890693416305788160905762011825079336880567461033322240015771102929696350161937950387427696385850443727777996483584464610046380722736790790188061964311222153985614287276995741553706506834906746892708903948496564047090014307484054609862129530262108669567834726352078060081889712109412073731026030466300060341737504223822014714056413752165841749368159510588178604096191956750941078391415634472219765129561622344109769892244712668402761549412177892054051266761597330660545704317210567759828757156904778495608968785747998059857467440128156068391746919684258227682866083662345263659558066864109212457286114506228470930775092735385388316268663664139056183180238043386636254075940621543717531670995823417070666005930452836389812129462051771646048498397195157405386923446893886593048680984896989809135802276892911038588008701926729269812453226891776546037663583893625479252643042517196958990266376741676514631089466493864064316127648074609662749196545969926051
e = 65537
c = 98280456757136766244944891987028935843441533415613592591358482906016439563076150526116369842213103333480506705993633901994107281890187248495507270868621384652207697607019899166492132408348789252555196428608661320671877412710489782358282011364127799563335562917707783563681920786994453004763755404510541574502176243896756839917991848428091594919111448023948527766368304503100650379914153058191140072528095898576018893829830104362124927140555107994114143042266758709328068902664037870075742542194318059191313468675939426810988239079424823495317464035252325521917592045198152643533223015952702649249494753395100973534541766285551891859649320371178562200252228779395393974169736998523394598517174182142007480526603025578004665936854657294541338697513521007818552254811797566860763442604365744596444735991732790926343720102293453429936734206246109968817158815749927063561835274636195149702317415680401987150336994583752062565237605953153790371155918439941193401473271753038180560129784192800351649724465553733201451581525173536731674524145027931923204961274369826379325051601238308635192540223484055096203293400419816024111797903442864181965959247745006822690967920957905188441550106930799896292835287867403979631824085790047851383294389
n = hex(n)
c = hex(c)
e = hex(e)
print(n)
p, q = wieners_attack(e, n)
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
print(f"p: {p}")
print(f"q: {q}")
print(long_to_bytes(pow(c, d, n)).decode())
